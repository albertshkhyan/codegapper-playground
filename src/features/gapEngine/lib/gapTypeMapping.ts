/**
 * Gap Type Mapping Configuration
 * 
 * Maps UI gap type selections to actual generated gap types.
 * Each UI checkbox controls specific, precise gap types for maximum accuracy.
 * 
 * To add a new gap type:
 * 1. Add the UI type to GapType in settingsStore.ts
 * 2. Add the mapping here with the actual gap types it should include
 * 3. Add the label to GAP_TYPE_LABELS in App.tsx
 */

export interface GapTypeMapping {
  /** UI type identifier (matches GapType from settingsStore) */
  uiType: string;
  /** Array of actual gap types generated by the gap engine */
  mappedTypes: string[];
  /** Human-readable description */
  description: string;
}

/**
 * Mapping from UI gap types to actual generated gap types.
 * Each entry defines which gap types are included when a UI checkbox is selected.
 */
export const GAP_TYPE_MAPPING: Record<string, GapTypeMapping> = {
  identifier: {
    uiType: 'identifier',
    mappedTypes: ['identifier'],
    description: 'Only actual identifier nodes (variable names, function names in declarations). Excludes function params, destructured vars, etc.'
  },
  
  operator: {
    uiType: 'operator',
    mappedTypes: [
      'assignmentOperator', // =, +=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, |=, ^=, **=
      'unaryOperator',      // !, ~, +, -, typeof, void, delete, ++, --
      'binaryOperator',     // +, -, *, /, %, **, ==, !=, ===, !==, <, >, <=, >=, <<, >>, >>>, &, |, ^, in, instanceof
      'logicalOperator'     // &&, ||, ??
    ],
    description: 'Only actual operator symbols. Excludes operator arguments/operands (those are identifiers/literals), full expressions'
  },
  
  propertyAccess: {
    uiType: 'propertyAccess',
    mappedTypes: [
      'propertyAccess',  // obj.property
      'methodName',      // obj.method() (method name)
      'methodCall',      // obj.method() (explicit method call)
      'bracketProperty' // obj['property']
    ],
    description: 'Property/method access patterns'
  },
  
  objectKey: {
    uiType: 'objectKey',
    mappedTypes: [
      'objectKey',         // { key: value }
      'objectShorthand'   // { key } (shorthand)
    ],
    description: 'Object property keys'
  },
  
  literal: {
    uiType: 'literal',
    mappedTypes: [
      'literal',          // String, number, boolean literals
      'arrayElement',     // Array element values
      'objectValue',      // Object property values
      'defaultParamValue' // Default parameter values
    ],
    description: 'Literal values (strings, numbers, etc.)'
  },
  
  template: {
    uiType: 'template',
    mappedTypes: [
      'templateExpr',      // Template literal expressions
      'returnExpr',        // Return statement expressions
      'expression',        // Complex expressions
      'ternaryTest',       // Ternary operator test
      'ternaryConsequent', // Ternary operator consequent
      'ternaryAlternate',  // Ternary operator alternate
      'controlKeyword'    // Control flow keywords (if, for, while, etc.)
    ],
    description: 'Template literals and complex expressions'
  }
};

/**
 * Get all UI gap types that are configured
 */
export function getUIGapTypes(): string[] {
  return Object.keys(GAP_TYPE_MAPPING);
}

/**
 * Get mapped gap types for a UI type
 */
export function getMappedGapTypes(uiType: string): string[] {
  return GAP_TYPE_MAPPING[uiType]?.mappedTypes || [];
}

/**
 * Check if a generated gap type matches any of the selected UI types
 */
export function matchesUIGapTypes(gapType: string, selectedUITypes: string[]): boolean {
  return selectedUITypes.some(uiType => {
    const mappedTypes = getMappedGapTypes(uiType);
    return mappedTypes.includes(gapType);
  });
}

/**
 * Get all mapped gap types for multiple UI types
 */
export function getAllMappedGapTypes(uiTypes: string[]): string[] {
  const allMapped: string[] = [];
  for (const uiType of uiTypes) {
    const mapped = getMappedGapTypes(uiType);
    allMapped.push(...mapped);
  }
  return [...new Set(allMapped)]; // Remove duplicates
}
